# Initial Data Model Design
This doc details the initial design for the data model. This represents how data will be
stored persistently for consumption by the API and other backend services. 

## Problem Description
Straightforwardly, we need a way to represent the data we plan to store such that it is
easy to read, update, and interpret. The perceived data requirements for this project
appear to be very simple, so we only need to translate them into a simple database model.

The way that data is represented here does not necessarily reflect how it will look in 
the API, although they should be similar so that programming with either is consistent. 

## Philosophy
The data we'll be storing should be easily represented with a relational database model. 
The model should reflect data owned by "Entities" (**Artist**, **Album**, Song, etc.), and how 
the entities relates to each other. 

For example, data owned by an **Artist** would include attributes such as the artist's name, 
and an **Artist** would also "own" multiple **Album**s. This could be represented as a one-to-many
relationship or a many-to-many relationship if we want to link multiple **Artist**s to a single
**Album**. Decisions like this ultimately cascade into larger design decisions about the project,
so it's important to get them right here with future considerations as to not be constantly 
changing the project's data model over time. Preferable changes to the data model are additions,
and we should look to avoid drastically modifying existing data as the project grows.

### Schema
Because the data is fundamentally based on entities (tables) and relationships, the data will
be designed with relational (SQL) databases in mind. 

## Requirements
As of now, requirements are fairly simple. For a minimum viable product, we are scoped to include
only a few pages. To serve these pages, we'll need to represent the following:

- **Artist**
- **Album**
- **Track**
- **User**
- **Purchase**

The data model doesn't necessarily describe all the capabilities of the backend, just the
data that we intend to store persistently. Some data may be generated by the server as needed,
and as such is not included in the data model.

## Models
Below is a standard _Entity-Relationship (ER)_ diagram which describes the data owned
by each entity and how the entities relate to each other.

```mermaid
---
title: Initial Data Model
---

erDiagram
    artist {
        int id PK 
        string(31) slug UK "Unique human-readable URL-safe identifier"
        string(255) name "The name of the Artist"
        string(16384) description "Long text description (Nullable)"
        string(63) location "The city in which the Artist is based (Nullable)"
        boolean is_group "Indicates if this Artist is a group or individual"
        string(255) profile_image_uri 
        string created_at "Timestamp"
        string updated_at "Timestamp"
    }
    album {
        int id PK 
        string(31) slug UK "Unique human-readable URL-safe identifier"
        string(255) name "The name of the Album"
        string(16384) description "Long text description (Nullable)"
        string(enum) type "Full-length, EP, Single, etc."
        int price_cents "USD cent value for price to buy full Album"
        string cover_art_uri 
        string release_date "The release date of the Album (Nullable timestamp)"
        int release_year "The release year of the Album (Nullable)"
        string created_at "Timestamp"
        string updated_at "Timestamp"
    }
    track {
        int id PK 
        string(31) slug UK "Unique human-readable URL-safe identifier"
        string(255) name "The name of the Track"
        string(16384) description "Long text description (Nullable)"
        int track_number "The number which describes the Track's ordering within its Album"
        int price_cents "USD cent value for price to buy individual Track (Nullable)"
        boolean is_streamable "Allows Users to stream the Track for free"
        boolean is_previewable "Allows Users to preview the Track before purchase"
        int streams "The number of streams the Track has gotten"
        int downloads "The number of downloads the Track has gotten"
        string content_uri "URI from which to stream or download the Track"
        int runtime_seconds "The length of the Track in seconds"
        string content_type "The format (MIME-type) of the Track's audio file"
        int size_bytes "The size in bytes of the Track's audio file"
        int sample_rate "The sample rate of the Track's audio file"
        int bit_depth "The bits per sample of the Track's audio file"
        string(255) checksum_sha256 "The SHA-256 checksum of the Track's audio file"
        string created_at "Timestamp"
        string updated_at "Timestamp"
    }
    user {
        int id PK 
        string(31) username UK ""
        string(255) email UK ""
        string(31) phone "Nullable"
        string created_at "Timestamp"
        string updated_at "Timestamp"
    }
    user_purchase_album {
        int id PK
        int user_id FK
        int album_id FK
        int purchase_price "Nullable"
        string(255) invoice_uri UK
        string purchased_at "Timestamp"
    }
    user_purchase_track {
        int id PK
        int user_id FK
        int track_id FK
        int purchase_price "Nullable"
        string(255) invoice_uri UK
        string purchased_at "Timestamp"
    }
    tag {
        int id PK
        string(31) slug UK "Unique human-readable URL-safe identifier"
        string(31) name "The pretty name of the Tag"
    }
    link {
        int id PK 
        string(255) url
        int artist_id FK
    }
    
    artist }o--|{ user : "artist_manager"
    artist }|--o{ album : "artist_album"
    artist }o--o{ tag : "tag_artist"
    artist ||--o{ link : "" 
    artist }o--o{ artist : "artist_members"
    album }|--|{ track : "album_track"
    album }o--o{ tag : "tag_album"
    track }|--o{ artist : "track_artist"
    track }o--o{ tag : "tag_track"
    user }o--o{ artist : "user_following"
    user }o--o{ album : "user_collection_album"
    user }o--o{ track : "user_collection_track"
    user_purchase_album }o--|| album : ""
    user_purchase_album }o--|| user : ""
    user_purchase_track }o--|| track : ""
    user_purchase_track }o--|| user : ""
```

## Notes

- While most of the many-to-many relationship tables are minimally simple (two columns, each containing IDs),
  there are a couple (`user_purchase_album`, `user_purchase_track`) that are
  defined explicitly within the diagram because they are a touch more complex.

### Artists
- If an **Artist** is a group, it can be linked to individual **Artist**s as members so that **User**s
can browse the **Artist**'s solo work or work with other groups. **User**s will also be able to browse 
the groups of which an **Artist** is a member from the individual **Artist**'s page.
- An **Artist** may be without a manager if a **User** uploads an **Album** and credits an artist who
doesn't have an account. A dummy **Artist** entity would be created and would somehow have to be claimed
by the real artist in the event they do decide to make an account.

### Album
- Allows **Artist**s to specify a `release_year` if the exact `release_date` is unknown

### Tracks
- The price for a **Track** is nullable in case the **Artist** doesn't want to allow individual **Track**s
to be purchased. If the **Artist** wants the **Track** to be free, the price can be set to zero.
- `is_streamable` allows users to stream a **Track** for free even if it is available for purchase
- **Track**s have their own relationship to **Artist**s in the case of a guest **Artist** or other contributor
who is not credited on the full album. If a **Track** does not relate to any **Artist**s, use the **Artist**s 
related to the **Track**'s **Album**.

### Links
- **Artist**s can display links on their page to social media, merch, etc.

### User
- The entity described by the diagram is the most basic data required to represent a **User**. 
The specification is likely to change drastically during the design for authentication and 
authorization.

### Purchase
- There are separate tables for **Album** and **Track** purchases so that the database can reliably
track the relationships between the relevant entities.
- The **Purchase** tables may change once we figure out our e-commerce platform.

## Future considerations
### Artists
- `verified` attribute to guard against impersonation
  - May also be used to claim **Artist**s without a linked **User**
- **Playlist** model
  - Could look something like
    ```mermaid
    erDiagram
    playlist {
        int id PK
        string(31) slug UK "Unique human-readable URL-safe identifier"
        string(255) name "The name of the Playlist"
        string(16384) description "Long text description (Nullable)"
        string(255) cover_art_uri "Nullable"
        int owner_id FK "User who owns this Playlist"
        string created_at "Timestamp"
        string updated_at "Timestamp"
    }
    playlist_track {
        int id PK
        int playlist_id FK
        int track_id FK
        int manual_order "The manual sorting order for the Track in the Playlist"
        string added_at "Timestamp"
        string updated_at "Timestamp"
    }  
    playlist ||--o{ playlist_track : ""
    playlist_track }o--|| track : ""
    ```